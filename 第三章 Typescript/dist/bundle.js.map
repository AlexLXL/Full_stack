{"version":3,"file":"bundle.js","sources":["../src/004.接口.ts","../src/index.ts"],"sourcesContent":["/**\r\n * interface: 用于描述对象\r\n */\r\n\r\n\r\n// 1.type和interface\r\n// type Sum = ((v1: number, v2: number) => number) | ((v1: string,  v2: string) => string)  // 联合类型时用\r\ninterface ISum {\r\n    (v1: number, v2: number): number\r\n}\r\nlet sum: ISum = (v1, v2  ) => v1 + v2\r\n\r\n\r\n// 2.基础使用\r\n// 注意点:给fn扩展属性的时候使用const\r\ninterface ICounter {\r\n    count: number\r\n    (): number\r\n}\r\nconst counter: ICounter = () => ++counter.count\r\ncounter.count = 0\r\ncounter();\r\n\r\n\r\n// 3.描述后台接口返回的字段\r\ninterface IFruit {\r\n    name: string\r\n    price?: number\r\n    // [prop:string]: any   // 3.1扩展字段\r\n}\r\n\r\nlet apple: IFruit = {\r\n    name: \"苹果\",\r\n}\r\n\r\nlet appleStrange: IFruit = {\r\n    name: \"奇怪的苹果\",\r\n    name02: '我多了一个字段'\r\n} as IFruit\r\n// 3.2 多了字段强转\r\n\r\n// 3.3 扩展字段\r\ninterface IPeachFruit extends IFruit {\r\n    color: string\r\n}\r\nlet peach: IPeachFruit = {\r\n    name: \"桃子\",\r\n    price: 5,\r\n    color: 'red'\r\n}\r\n\r\n// 3.4 满足条件就可以赋值\r\nlet fruit: IFruit = peach\r\n\r\nconsole.log(apple)\r\nconsole.log(appleStrange)\r\nconsole.log(peach)\r\nconsole.log(fruit)\r\n\r\n// 4.接口的交集\r\n// 交集出来的东西即满足A,又满足B\r\ninterface A {\r\n    hasHand: string\r\n}\r\ninterface B {\r\n    hasFoot: string\r\n}\r\ntype P = A & B  // (与运算是同1才是1，所以是交集; 或运算是有1就是1,所以是并集)\r\nlet person: P = {\r\n    hasHand: '1',\r\n    hasFoot: '1',\r\n    // hashead: '1'\r\n}\r\n\r\nfunction mixin<T extends object, E extends object>(o1: T, o2: E) {\r\n    return {...o1, ...o2}\r\n}\r\nlet r1 = mixin({a: 1}, {a: 'aa', b: 'bb'})\r\nconsole.log(r1) // {a: 'aa', b: 'bb'}\r\n\r\nexport default {}","// import baseData from './001.基础数据类型'\r\n// import fnType from './002.函数的类型'\r\n// import classKnowledge from './003.类'\r\nimport interfaceKnowledge from './004.接口'\r\n// import gen from './005.泛型'\r\n\r\n// console.log(baseData)\r\n// console.log(fnType)\r\n// console.log(classKnowledge)\r\nconsole.log(interfaceKnowledge)\r\n// console.log(gen)\r\n\r\n// let aaa:string = '333'\r\n// console.log(aaa)\r\n\r\n// keyof any => string | number | symbol\r\n"],"names":[],"mappings":";;;;;IAAA;;;IA+BA,IAAI,KAAK,GAAW;QAChB,IAAI,EAAE,IAAI;KACb,CAAA;IAED,IAAI,YAAY,GAAW;QACvB,IAAI,EAAE,OAAO;QACb,MAAM,EAAE,SAAS;KACV,CAAA;IAOX,IAAI,KAAK,GAAgB;QACrB,IAAI,EAAE,IAAI;QACV,KAAK,EAAE,CAAC;QACR,KAAK,EAAE,KAAK;KACf,CAAA;IAED;IACA,IAAI,KAAK,GAAW,KAAK,CAAA;IAEzB,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;IAClB,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAA;IACzB,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;IAClB,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;IAiBlB,SAAS,KAAK,CAAqC,EAAK,EAAE,EAAK;QAC3D,uCAAW,EAAE,GAAK,EAAE,EAAC;IACzB,CAAC;IACD,IAAI,EAAE,GAAG,KAAK,CAAC,EAAC,CAAC,EAAE,CAAC,EAAC,EAAE,EAAC,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAC,CAAC,CAAA;IAC1C,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAA;AAEf,6BAAe,EAAE;;IChFjB;IAIA;IAEA;IACA;IACA;IACA,OAAO,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAA;IAC/B;IAEA;IACA;IAEA;;;;;;"}