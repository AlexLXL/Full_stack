/**
 * 题目: 火车排序问题
 *              ↗---→---↘
 * 输入----→---|         |---------→输出
 *              ↘---→---↗
 *
 * 过程中每节火车只能往右走,看最后能不能走出对应顺序
 *
 * 输入: 原数组[1,2,3,4,5]、排序后数组:[1,3,2,4,5]
 * 输出: 是否能转换
 *
 * 分析题目:
 *  1.把图重新理解为下面方式
 *                ↗---→---↘③
 *                ↑       ↓
 *  输入①----→--- →---→---→ ---------→输出②
 *
 *  2.这样就能发现其实只是多了一个上方的队列③
 *  3.如果判断是否能转换呢?
 *      a.成功场景:
 *          [1,2]从①->②,
 *          [3]从①->③,
 *          [4,5]从①->②,
 *          [3]从③->②
 *          最后组成[1,2,4,5,3]
 *      b.不成功场景: 想要[1,2,5,4,3]
 *          [1,2]从①->②,
 *          [3]从①->③,
 *          [4]从①->③,
 *          [5]从①->②
 *          最后组成[1,2,5] 和 [3,4]; [3,4]已经无法反过来
 *
 *      c.观察两种情况: 在不成功的时候③会有值遗留,
 *          所以③.length === 0即成功
 *             ③.length !== 0即失败
 *          => 推导出整个函数几乎只关注③的进值和出值，①②的值变化只是辅助作用
 *
 * 拆分题目:
 *  1.输入数组, 参数o
 *  2.目标数组, 参数t
 *  3.需要一个中间数组, 变量q
 *  4.返回boolean
 *
 */


function isTrans(o, t) {
    let q = []
    for (let x of t){
        // q队列出值
        if (x === q[0]) {
            q.shift()
        }
        // q队列进值
        let y = null
        while(o.length && x !== (y = o.shift())) {
            q.push(y)
        }
    }
    return q.length === 0
}

console.log(isTrans([1, 2, 3, 4, 5], [1, 2, 5, 3, 4]))  // OUTPUT: true
console.log(isTrans([1, 2, 3, 4, 5], [1, 2, 5, 4, 3]))  // OUTPUT: false

// 性能问题
// [].shift() 操作都是O(n)的,可以自己手写一个队列，将o、t、q都改为队列形式，时间复杂度就变成O(1)了