
### 颠倒二进制位

#### 颠倒给定的 32 位无符号整数的二进制位。

示例:
> 输入：n = 00000010100101000001111010011100 
  输出：964176192 (00111001011110000010100101000000)  
  解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，  
       因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。  
>  
> 输入：n = 11111111111111111111111111111101  
  输出：3221225471 (10111111111111111111111111111111)  
  解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，  
       因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。  

---

思路一: 
1.双指针循环, 拿出头尾, 加到结果中

思路二:
1.循环拿出尾部, 加到结果中

思路三:
1.分治; 利用位掩码和位移运算

---

```
// 思路一
var reverseBits = function(n) {
    let head = 1 << 31 >>> 0
    let tail = 1
    let result = 0
    for(let i = 0; i < 16; i++) {
        let v1 = (n & head) ? 1 : 0
        let v2 = (n & tail) ? 1 : 0
        result = (result | (v2 << (31 - i) >>> 0)) >>> 0
        result = (result | (v1 << i)) >>> 0
        head = head >>> 1
        tail = tail << 1
    }
    return result
};

// 思路二
var reverseBits = function(n) {
    let rev = 0;
    for (let i = 0; i < 32 && n > 0; ++i) {
        rev |= (n & 1) << (31 - i);
        n >>>= 1;
    }
    return rev >>> 0;
}

// 思路三
var reverseBits = function(n) {
    const M1 = 0x55555555; // 01010101010101010101010101010101
    const M2 = 0x33333333; // 00110011001100110011001100110011
    const M4 = 0x0f0f0f0f; // 00001111000011110000111100001111
    const M8 = 0x00ff00ff; // 00000000111111110000000011111111

    n = n >>> 1 & M1 | (n & M1) << 1;
    n = n >>> 2 & M2 | (n & M2) << 2;
    n = n >>> 4 & M4 | (n & M4) << 4;
    n = n >>> 8 & M8 | (n & M8) << 8;
    return (n >>> 16 | n << 16) >>> 0;
};
```

* 技巧: 无 

* 优化空间: 无 

* 学习: 无 

* 总结: 无
